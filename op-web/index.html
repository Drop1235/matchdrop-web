<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MatchDrop - ãƒ†ãƒ‹ã‚¹ãƒˆãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆå¯¾æˆ¦è¡¨</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../src/css/styles.css">
  <link rel="stylesheet" href="../src/css/tournament-modal.css">
  <link rel="icon" href="../assets/icon.png">
  <style>
    .cloud-controls { display:flex; gap:8px; align-items:center; margin-left:8px; }
  </style>
</head>
<body>
  <!-- æ–°è¦å¤§ä¼šåå…¥åŠ›ãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆUIã¯æ—¢å­˜è¸è¥²ï¼‰ -->
  <div id="tournament-modal">
    <div class="modal-content">
      <h2>æ–°è¦å¤§ä¼šä½œæˆ</h2>
      <label for="tournament-name-input">å¤§ä¼šåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</label>
      <input type="text" id="tournament-name-input" maxlength="30" autocomplete="off" />
      <div class="modal-btns">
        <button class="ok-btn" id="tournament-modal-ok">OK</button>
        <button class="cancel-btn" id="tournament-modal-cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
      </div>
    </div>
  </div>

  <header>
    <div class="app-brand">
      <img src="../assets/icon.png" alt="MatchDrop icon" class="logo-icon">
      <span class="app-name">MatchDrop</span>
    </div>
    <nav style="display: flex; align-items: center; gap: 8px;">
      <button id="board-view-btn" class="active">å¯¾æˆ¦è¡¨</button>
      <button id="history-view-btn">è©¦åˆå±¥æ­´</button>
      <label for="tournament-select" style="margin-left: 16px;">å¤§ä¼š:</label>
      <select id="tournament-select" style="min-width: 150px;"></select>
      <button id="copy-tid-btn" title="å¤§ä¼šIDã‚’ã‚³ãƒ”ãƒ¼" style="margin-left:4px; font-size:0.9em; line-height:1; padding:4px 6px;">ğŸ“‹</button>
      <button id="add-tournament-btn" style="background-color: #2196f3; color: #fff;">æ–°è¦å¤§ä¼š</button>
      <button id="delete-tournament-btn" title="å¤§ä¼šã‚’å‰Šé™¤" style="background: none; border: none; cursor: pointer; font-size: 1.3em; color: #f44336; padding: 0 8px;">ğŸ—‘ï¸</button>

      <div class="cloud-controls">
        <button id="cloud-pull-btn" title="ã‚¯ãƒ©ã‚¦ãƒ‰ã‹ã‚‰å–å¾—ï¼ˆã‚¯ãƒ©ã‚¦ãƒ‰å„ªå…ˆï¼‰">ğŸ”„ æ›´æ–°</button>
        <button id="cloud-push-btn" title="ç¾åœ¨ã®çŠ¶æ…‹ã‚’ã‚¯ãƒ©ã‚¦ãƒ‰ã¸ä¿å­˜">â˜ï¸ ä¿å­˜</button>
        <button id="toggle-admin-btn" title="ç®¡ç†è€…/é–²è¦§è€… åˆ‡æ›¿">ğŸ‘¤ ç®¡ç†</button>
        <span id="last-sync-label" style="font-size:0.85em;color:#666;">æœ€çµ‚æ›´æ–°: -</span>
      </div>
      
    </nav>
  </header>
  <!-- Viewer-mode admin re-entry button (shown only when body has viewer-mode) -->
  <button id="viewer-admin-entry" class="viewer-admin-entry" title="ç®¡ç†ãƒ¢ãƒ¼ãƒ‰">ğŸ‘¤</button>

  <main>
    <!-- Board View -->
    <section id="board-view" class="active-view">
      <div id="court-settings" class="court-settings">
        <div class="court-settings-header">
          <button id="add-match-btn" class="add-match-btn-prominent">è©¦åˆè¿½åŠ </button>
          <div class="court-count-controls" style="margin-left:auto; margin-right:8px;">
            <button id="decrease-courts-btn">-</button>
            <span id="court-count-display" class="court-count-display">12</span>
            <button id="increase-courts-btn">+</button>
          </div>
          <div class="export-controls" style="margin-right:8px;">
            <select id="board-export-type" style="margin-right:4px;">
              <option value="csv">CSVå½¢å¼</option>
              <option value="screenshot">ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ</option>
            </select>
            <button id="board-export-btn" class="export-btn">æ›¸ãå‡ºã—</button>
          </div>
          <button id="delete-all-matches-btn" class="delete-all-btn">å…¨å‰Šé™¤</button>
        </div>
      </div>
      <div id="court-grid" class="court-grid"></div>
      <div class="unassigned-section">
        <div class="unassigned-header">æœªå‰²å½“ã®è©¦åˆ</div>
        <div id="unassigned-cards" class="unassigned-cards"></div>
      </div>
    </section>

    <!-- History View -->
    <section id="history-view" class="hidden-view">
      <div class="filter-controls">
        <div class="filter-group">
          <label for="court-filter">ã‚³ãƒ¼ãƒˆ:</label>
          <select id="court-filter"><option value="all">å…¨ã‚³ãƒ¼ãƒˆ</option></select>
        </div>
        <div class="filter-group">
          <label for="date-filter">æ—¥ä»˜:</label>
          <input type="date" id="date-filter">
          <button id="clear-date-filter">ã‚¯ãƒªã‚¢</button>
        </div>
      </div>
      <div id="history-card-view" class="history-card-view">
        <div id="history-court-grid" class="court-grid history-court-grid"></div>
      </div>
    </section>
  </main>

  <!-- Add Match Modal (missing in web copy; required by app.js) -->
  <div id="add-match-modal" class="modal">
    <div class="modal-content">
      <span class="close-modal">&times;</span>
      <h2>æ–°è¦è©¦åˆè¿½åŠ </h2>
      <form id="add-match-form">
        <div class="form-group">
          <label>è©¦åˆå½¢å¼:</label>
          <select id="game-format-select" name="game-format" class="form-control">
            <option value="5game">5G</option>
            <option value="4game1set">4G1set</option>
            <option value="4game1set_ntb">4G1set NoTB</option>
            <option value="6game1set">6G1set</option>
            <option value="6game1set_ntb">6G1set NoTB</option>
            <option value="8game1set">8G-Pro</option>
            <option value="4game2set">4G2set+10MTB</option>
            <option value="6game2set">6G2set+10MTB</option>
            <option value="4game3set">4G3set</option>
            <option value="6game3set">6G3set</option>
          </select>
        </div>
        <div class="form-group">
          <label for="category-input">ã‚«ãƒ†ã‚´ãƒª (ä»»æ„):</label>
          <input type="text" id="category-input" placeholder="ä¾‹: ç”·å­ã‚·ãƒ³ã‚°ãƒ«ã‚¹ 12æ­³ä»¥ä¸Š">
        </div>
        <div class="form-group">
          <label for="player-a">é¸æ‰‹A:</label>
          <input type="text" id="player-a" required>
        </div>
        <div class="form-group">
          <label for="player-b">é¸æ‰‹B:</label>
          <input type="text" id="player-b" required>
        </div>
        <div class="form-group">
          <label for="court-select">ã‚³ãƒ¼ãƒˆ (ä»»æ„):</label>
          <select id="court-select">
            <option value="">æœªå‰²å½“</option>
          </select>
        </div>
        <div class="form-group">
          <label for="position-select">ä½ç½® (ä»»æ„):</label>
          <select id="position-select">
            <option value="">æœªå‰²å½“</option>
            <option value="current">ç¾åœ¨ã®è©¦åˆ</option>
            <option value="next">æ¬¡ã®è©¦åˆ</option>
            <option value="next2">æ¬¡ã€…ã®è©¦åˆ</option>
            <option value="next3">ç¬¬4è©¦åˆ</option>
            <option value="next4">ç¬¬5è©¦åˆ</option>
            <option value="next5">ç¬¬6è©¦åˆ</option>
          </select>
        </div>
        <button type="submit">è¿½åŠ </button>
      </form>
    </div>
  </div>

  <!-- ãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <!-- Supabase UMD -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>

  <!-- URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰å¤§ä¼šID/åç§°ã‚’å–ã‚Šè¾¼ã¿ï¼ˆtid/tnameï¼‰ã€‚app.js åˆæœŸåŒ–å‰ã«å®Ÿè¡Œã™ã‚‹å¿…è¦ã‚ã‚Š -->
  <script>
    (function () {
      try {
        const sp = new URLSearchParams(location.search);
        const tid = sp.get('tid');
        const tname = sp.get('tname');
        if (tid) {
          console.log('[OP ingest] query params detected', { tid, tname });
          const raw = localStorage.getItem('tournaments');
          const list = raw ? JSON.parse(raw) : [];
          if (!Array.isArray(list)) {
            localStorage.setItem('tournaments', JSON.stringify([]));
          }
          let nextList = Array.isArray(list) ? list.slice() : [];
          const idx = nextList.findIndex(t => t && t.id === tid);
          if (idx === -1) {
            // æ–°è¦è¿½åŠ ï¼ˆåç§°ãŒç„¡ã‘ã‚Œã°IDã‚’æš«å®šåã«ã™ã‚‹ï¼‰
            nextList.push({ id: tid, name: tname || tid });
          } else {
            // æ—¢å­˜ã®åç§°ã‚’æœ€æ–°ã«æ›´æ–°ï¼ˆãƒ–ãƒ©ãƒ³ã‚±ãƒƒãƒˆå´ã®å¤§ä¼šåã‚’å„ªå…ˆï¼‰
            nextList[idx] = { id: tid, name: tname || nextList[idx].name || tid };
          }
          localStorage.setItem('tournaments', JSON.stringify(nextList));
          localStorage.setItem('currentTournamentId', tid);
          console.log('[OP ingest] tournaments updated', nextList);
        } else {
          console.log('[OP ingest] no tid in URL');
        }
      } catch (e) {
        console.warn('[OP] failed to ingest tid/tname from URL', e);
      }
    })();
  </script>

  <!-- ã‚¢ãƒ—ãƒªæ—¢å­˜ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆç›¸å¯¾å‚ç…§ï¼šå¾Œã§op-webé…ä¸‹ã«ã‚³ãƒ”ãƒ¼äºˆå®šï¼‰ -->
  <script src="../src/js/integrations/leagueWebhook.js?v=2025-10-31"></script>
  <script src="../src/js/matchDropStorage.js?v=2025-10-23-ingest2"></script>
  <script src="../src/js/local-storage.js?v=2025-10-23-ingest2"></script>
  <script src="../src/js/favicon.js?v=2025-10-23-ingest2"></script>
  <script src="../src/js/database.js?v=2025-10-23-ingest2"></script>
  <script src="../src/js/matchCard.js?v=2025-10-23-ingest2"></script>
  <script src="../src/js/board.js?v=2025-10-23-ingest2"></script>
  <script src="../src/js/history.js?v=2025-10-23-ingest2"></script>
  <script src="../src/js/app.js?v=2025-10-23-ingest2"></script>

  <!-- ã‚¯ãƒ©ã‚¦ãƒ‰é€£æº -->
  <script type="module">
    import { SUPABASE_URL, SUPABASE_ANON_KEY } from '/src/js/supabase-config.js?v=2025-11-03-op2';
    // Use imported values, but if they point to an old host, force override to the correct project
    let SB_URL = SUPABASE_URL;
    let SB_KEY = SUPABASE_ANON_KEY;
    const EXPECTED = 'https://gdfdunsoluxuiuzfrexs.supabase.co';
    if (typeof SB_URL !== 'string' || SB_URL.indexOf('gdfdunsoluxuiuzfrexs.supabase.co') === -1) {
      console.warn('[OP] Detected stale SUPABASE_URL, forcing override');
      SB_URL = EXPECTED;
      SB_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdkZmR1bnNvbHV4dWl1emZyZXhzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAyNTUxODksImV4cCI6MjA3NTgzMTE4OX0.RTWFEoqqMVdfZU8H8Xcsjm-PT7XWFXm1hJG7HqBJOBs';
    }
    console.log('[OP] Using SUPABASE_URL =', SB_URL);

    // Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
    const supabase = window.supabase.createClient(SB_URL, SB_KEY);

    // ç°¡æ˜“ãƒ‘ã‚¹ã‚³ãƒ¼ãƒ‰
    const PASSCODE_KEY = 'op_admin_passcode';
    const ADMIN_FLAG_KEY = 'op_is_admin';

    function isAdmin() {
      return localStorage.getItem(ADMIN_FLAG_KEY) === '1';
    }

    async function ensureTables() {
      // ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆã¯ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã§è¡Œã†é‹ç”¨ã€‚ã“ã“ã§ã¯å­˜åœ¨å‰æã€‚
      return true;
    }

    async function getDataset(tournamentId, type) {
      // Be robust to accidental duplicates: fetch the latest by updated_at
      const { data, error } = await supabase
        .from('datasets')
        .select('data, updated_at')
        .eq('tournament_id', tournamentId)
        .eq('type', type)
        .order('updated_at', { ascending: false })
        .limit(1);
      if (error) throw error;
      if (Array.isArray(data) && data.length > 0) return data[0];
      return null;
    }

    async function upsertDataset(tournamentId, type, payload) {
      const { error } = await supabase
        .from('datasets')
        .upsert({ tournament_id: tournamentId, type, data: payload, updated_at: new Date().toISOString() }, { onConflict: 'tournament_id,type' });
      if (error) throw error;
      return true;
    }

    // Simple toast helper (auto-dismiss, bottom-right)
    function showToast(message, opts = {}) {
      try {
        const duration = opts.duration ?? 2000;
        const containerId = 'toast-container';
        let container = document.getElementById(containerId);
        if (!container) {
          container = document.createElement('div');
          container.id = containerId;
          container.style.position = 'fixed';
          container.style.right = '12px';
          container.style.bottom = '12px';
          container.style.display = 'flex';
          container.style.flexDirection = 'column';
          container.style.gap = '8px';
          container.style.zIndex = '9999';
          document.body.appendChild(container);
        }
        const el = document.createElement('div');
        el.textContent = message;
        el.style.padding = '8px 12px';
        el.style.background = 'rgba(0,0,0,0.85)';
        el.style.color = '#fff';
        el.style.borderRadius = '6px';
        el.style.fontSize = '13px';
        el.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
        el.style.opacity = '0';
        el.style.transition = 'opacity 150ms ease-out';
        container.appendChild(el);
        requestAnimationFrame(() => { el.style.opacity = '1'; });
        setTimeout(() => {
          el.style.opacity = '0';
          setTimeout(() => { el.remove(); }, 200);
        }, duration);
      } catch {}
    }

    // ãƒ­ãƒ¼ã‚«ãƒ«<->ã‚¯ãƒ©ã‚¦ãƒ‰
    // å¤§ä¼šIDã¯ URL ?tid= ã‚’æœ€å„ªå…ˆã€ãã®æ¬¡ã« localStorageã€æœ€å¾Œã«æ—¢å­˜ãƒªã‚¹ãƒˆã®å˜ç‹¬ã‚¨ãƒ³ãƒˆãƒª
    function getTournamentId() {
      try {
        const sp = new URLSearchParams(location.search);
        const urlTid = sp.get('tid');
        if (urlTid) return urlTid;
      } catch {}
      const lsTid = localStorage.getItem('currentTournamentId');
      if (lsTid) return lsTid;
      try {
        const list = JSON.parse(localStorage.getItem('tournaments') || '[]');
        if (Array.isArray(list) && list.length === 1 && list[0] && list[0].id) {
          localStorage.setItem('currentTournamentId', list[0].id);
          return list[0].id;
        }
      } catch {}
      return 'default';
    }

    async function pullLatest() {
      try {
        // Guard: avoid concurrent or repeated pulls during this session
        if (sessionStorage.getItem('op_pulling') === '1') return;
        sessionStorage.setItem('op_pulling', '1');
        const tid = getTournamentId();
        console.log('[OP] pullLatest clicked. tid=', tid);
        // keep copy button tooltip reflecting current tid
        try { const copyBtn = document.getElementById('copy-tid-btn'); if (copyBtn) copyBtn.title = 'å¤§ä¼šIDã‚’ã‚³ãƒ”ãƒ¼: ' + tid; } catch {}
        const ds = await getDataset(tid, 'matches');
        const label = document.getElementById('last-sync-label');
        if (ds && ds.data && Array.isArray(ds.data.matches)) {
          const key = (typeof window.getMatchDataKey === 'function') ? window.getMatchDataKey(tid) : 'tennisTournamentMatches_' + tid;
          const matches = ds.data.matches;
          console.log('[OP] pullLatest matches len=', matches.length, 'saveKey=', key);
          // If incoming is empty but local has data, do NOT overwrite to avoid losing unsaved work
          try {
            const localRaw = localStorage.getItem(key);
            const localArr = localRaw ? JSON.parse(localRaw) : [];
            const localLen = Array.isArray(localArr) ? localArr.length : 0;
            // Also consider in-memory db or current DOM state
            let memLen = 0;
            try { if (window.db && typeof window.db.getAllMatches === 'function') { const m = await window.db.getAllMatches(); memLen = Array.isArray(m) ? m.length : 0; } } catch {}
            const domHasCards = !!document.querySelector('.match-card');
            // Use only runtime state (memory/DOM) to judge preservation; localStorage may be stale after deletions
            const effectiveLocal = Math.max(memLen, domHasCards ? 1 : 0);
            if ((matches?.length || 0) === 0 && effectiveLocal > 0) {
              console.warn('[OP] Cloud dataset empty; preserving local data.');
              const nowIso = new Date().toISOString();
              localStorage.setItem('lastSyncTime', nowIso);
              if (label) label.textContent = 'æœ€çµ‚æ›´æ–°: ' + new Date(nowIso).toLocaleString('ja-JP');
              try { if (typeof showToast === 'function') showToast('ã‚¯ãƒ©ã‚¦ãƒ‰ãŒç©ºã ã£ãŸãŸã‚ãƒ­ãƒ¼ã‚«ãƒ«ã‚’ä¿æŒã—ã¾ã—ãŸ'); } catch {}
              return;
            }
            // If cloud has fewer records than local/memory, regard cloud as older and keep local
            if ((matches?.length || 0) < memLen) {
              console.warn('[OP] Cloud appears older (fewer records). Preserving local. cloud=', matches?.length || 0, 'local=', localLen, 'mem=', memLen);
              const nowIso = new Date().toISOString();
              localStorage.setItem('lastSyncTime', nowIso);
              if (label) label.textContent = 'æœ€çµ‚æ›´æ–°: ' + new Date(nowIso).toLocaleString('ja-JP');
              try { if (typeof showToast === 'function') showToast('ãƒ­ãƒ¼ã‚«ãƒ«ã‚’ä¿æŒã—ã¾ã—ãŸï¼ˆã‚¯ãƒ©ã‚¦ãƒ‰ãŒå¤ã„å¯èƒ½æ€§ï¼‰'); } catch {}
              return;
            }
          } catch {}

          // If cloud has data, first normalize IDs to avoid cross-league collisions
          const normalizeIds = (arr) => {
            try {
              return (Array.isArray(arr) ? arr : []).map(m => {
                try {
                  const ln = m?.leagueName || m?.category || '';
                  const ext = (m?.externalId ?? m?.matchExternalId);
                  if (ln && (ext !== undefined && ext !== null)) {
                    const composite = `${ln}::${String(ext)}`;
                    // Preserve original externalId for downstream systems
                    const orig = (m.originalExternalId !== undefined) ? m.originalExternalId : (m.externalId ?? m.matchExternalId);
                    return { ...m, id: (m.id && String(m.id) === composite) ? m.id : composite, originalExternalId: orig };
                  }
                } catch {}
                return m;
              });
            } catch { return Array.isArray(arr) ? arr : []; }
          };
          const normalizedCloud = normalizeIds(matches);
          const rev = (ds && ds.data && ds.data._rev) ? Number(ds.data._rev) : 0;
          let lastSeenRev = 0;
          try { lastSeenRev = Number(localStorage.getItem('lastSeenRev_' + tid) || '0'); } catch {}
          // MERGE with local in-memory/localStorage to preserve local-only cards
          const prevRaw = localStorage.getItem(key) || '[]';
          const prevArr = (()=>{ try { return JSON.parse(prevRaw) } catch { return [] } })();
          // Build id map for cloud
          const cloudById = new Map();
          const cloudArr = Array.isArray(normalizedCloud) ? normalizedCloud : [];
          for (const m of cloudArr) { if (m && m.id != null) cloudById.set(String(m.id), m); }
          // Gather local sources
          let memArr = [];
          try { if (window.db && typeof window.db.getAllMatches === 'function') { memArr = await window.db.getAllMatches(); } } catch {}
          const localCandidates = [ ...(Array.isArray(prevArr)?prevArr:[]), ...(Array.isArray(memArr)?memArr:[]) ];
          // Deleted tombstones: ignore them if cloud is newer (rev) or cloud has more matches than current memory
          const shouldIgnoreTombstones = ((normalizedCloud?.length || 0) > memArr.length) || (rev && rev > lastSeenRev);
          let deletedSet = new Set();
          if (!shouldIgnoreTombstones) {
            try {
              const delKey = (typeof window.getDeletedIdsKey === 'function') ? window.getDeletedIdsKey() : ('deletedMatchIds_' + tid);
              const raw = localStorage.getItem(delKey);
              const arr = raw ? JSON.parse(raw) : [];
              deletedSet = new Set(Array.isArray(arr) ? arr.map(x => String(x)) : []);
            } catch {}
          }
          // Start with cloud and append any local-only by id
          const merged = [...cloudArr];
          const mergedIds = new Set([...cloudById.keys()]);
          for (const lm of localCandidates) {
            if (!lm || lm.id == null) continue;
            const idStr = String(lm.id);
            if (deletedSet.has(idStr)) continue; // honor deletions
            if (!mergedIds.has(idStr)) { merged.push(lm); mergedIds.add(idStr); }
          }
          // Final safety: if cloud is empty but we have any local source, do not overwrite/wipe
          try {
            const cloudCount = Array.isArray(cloudArr) ? cloudArr.length : 0;
            if (cloudCount === 0) {
              const localCount = Array.isArray(prevArr) ? prevArr.length : 0;
              const memCount = Array.isArray(localCandidates) ? localCandidates.length : 0;
              if (localCount > 0 || memCount > 0) {
                console.warn('[OP] Abort overwrite: cloud empty while local exists (local=', localCount, 'mem=', memCount, ')');
                const nowIso = new Date().toISOString();
                localStorage.setItem('lastSyncTime', nowIso);
                if (label) label.textContent = 'æœ€çµ‚æ›´æ–°: ' + new Date(nowIso).toLocaleString('ja-JP');
                return;
              }
            }
          } catch {}

          // Persist merged dataset
          localStorage.setItem(key, JSON.stringify(merged));
          try { if (rev) localStorage.setItem('lastSeenRev_' + tid, String(rev)); } catch {}
          try {
            if (window.db && typeof window.db.getAllMatches === 'function') {
              // Replace in-memory dataset if it differs from merged
              const current = await window.db.getAllMatches();
              const currLen = Array.isArray(current) ? current.length : 0;
              if ((currLen !== merged.length) || JSON.stringify(current) !== JSON.stringify(merged)) {
                if (typeof window.db.deleteAllMatches === 'function') {
                  await window.db.deleteAllMatches({ skipTombstone: true });
                }
                if (typeof window.db.addMatch === 'function') {
                  for (const m of merged) { await window.db.addMatch(m); }
                }
              }
            }
          } catch (e) { console.warn('sync in-memory after pull failed', e); }

          // Cloud is source of truth now: clear tombstones for this tournament so future reloads don't filter pulled IDs
          try {
            const delKey = (typeof window.getDeletedIdsKey === 'function') ? window.getDeletedIdsKey() : ('deletedMatchIds_' + tid);
            localStorage.removeItem(delKey);
          } catch {}

          // Apply shared settings (courtCount, courtNames) if present
          const settings = ds.data.settings || {};
          if (settings && typeof settings.courtCount === 'number') {
            try {
              const cc = parseInt(settings.courtCount, 10);
              if (Number.isFinite(cc) && cc > 0) {
                // Save both per-tournament and legacy keys for compatibility
                localStorage.setItem('courtCount_' + tid, String(cc));
                localStorage.setItem('courtCount', String(cc));
              }
            } catch {}
          }
          if (settings && settings.courtNames && typeof settings.courtNames === 'object') {
            try {
              localStorage.setItem('courtNames', JSON.stringify(settings.courtNames));
            } catch {}
          }

          const nowIso = new Date().toISOString();
          localStorage.setItem('lastSyncTime', nowIso);
          if (label) label.textContent = 'æœ€çµ‚æ›´æ–°: ' + new Date(nowIso).toLocaleString('ja-JP');
          // Only reload if dataset actually changed and is non-empty to avoid clearing transiently
          const changed = JSON.stringify(prevArr) !== JSON.stringify(merged);
          if (changed && merged.length > 0) {
            // Mark that we have pulled once in this session to prevent re-auto-pull loop after reload
            try { sessionStorage.setItem('op_auto_pulled_once', '1'); } catch {}
            // Cache-busting reload so that app.js reinitializes with the newly written localStorage
            try {
              const u = new URL(location.href);
              u.searchParams.set('_v', Date.now());
              location.replace(u.toString());
            } catch {
              location.reload();
            }
          }
          return;
        }
        console.warn('[OP] pullLatest: no dataset for this tournament or empty');
        const nowIso = new Date().toISOString();
        localStorage.setItem('lastSyncTime', nowIso);
        if (label) label.textContent = 'æœ€çµ‚æ›´æ–°: ' + new Date(nowIso).toLocaleString('ja-JP');
        alert('ã‚¯ãƒ©ã‚¦ãƒ‰ã«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\nå¤§ä¼šID: ' + tid + '\nPCå´ã§ã€Œç®¡ç†ã€â†’ã€Œä¿å­˜ã€ã‚’å®Ÿè¡Œã—ã€å…±æœ‰URLã® tid ãŒä¸€è‡´ã—ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
      } catch (err) {
        console.error('[OP] pullLatest error', err);
        const label = document.getElementById('last-sync-label');
        if (label) label.textContent = 'æœ€çµ‚æ›´æ–°: ã‚¨ãƒ©ãƒ¼';
        alert('æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + (err?.message || err));
      } finally {
        // Release guard
        try { sessionStorage.setItem('op_pulling', '0'); } catch {}
      }
    }

    // ãƒ¡ã‚¿æƒ…å ±ï¼ˆã‚«ãƒ†ã‚´ãƒªãªã©ï¼‰ã‚’å–å¾—ã—ã¦UIã«åæ˜ 
    async function pullMeta() {
      try {
        const tid = getTournamentId();
        const ds = await getDataset(tid, 'meta');
        const cat = ds && ds.data ? ds.data.category : '';
        const el = document.getElementById('category-input');
        if (el && cat && !el.value) el.value = cat;
      } catch (e) {
        console.warn('[OP] pullMeta failed', e);
      }
    }

    async function pushNow() {
      if (!isAdmin()) {
        alert('ç®¡ç†è€…ãƒ¢ãƒ¼ãƒ‰ã§ã®ã¿ä¿å­˜ã§ãã¾ã™ã€‚');
        return;
      }
      // ãƒ­ãƒ¼ã‚«ãƒ«ã‹ã‚‰å–å¾—
      let matches = [];
      if (window.db && typeof window.db.getAllMatches === 'function') {
        matches = await window.db.getAllMatches();
      }
      const tid = getTournamentId();
      console.log('[OP] pushNow tid=', tid, 'matches.len=', matches?.length || 0);
      // Safety: avoid pushing empty if local actually has data
      if (!matches || matches.length === 0) {
        try {
          const key = (typeof window.getMatchDataKey === 'function') ? window.getMatchDataKey(tid) : 'tennisTournamentMatches_' + tid;
          const raw = localStorage.getItem(key);
          const arr = raw ? JSON.parse(raw) : [];
          if (Array.isArray(arr) && arr.length > 0) {
            console.warn('[OP] in-memory empty; using localStorage dataset for push:', arr.length);
            matches = arr;
          }
        } catch {}
      }
      // If still empty but DOM has cards, abort to prevent wiping cloud
      if ((!matches || matches.length === 0) && document.querySelector('.match-card')) {
        showToast('ä¿å­˜ã‚’ä¸­æ­¢ã—ã¾ã—ãŸï¼ˆæ¤œå‡º: ç”»é¢ã«ã¯ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹ã®ã«ãƒ‡ãƒ¼ã‚¿ãŒç©ºï¼‰');
        return;
      }
      // Collect board settings to share across devices
      const board = window.boardInstance || window.board;
      const settings = {
        courtCount: board && typeof board.numberOfCourts === 'number' ? board.numberOfCourts : undefined,
        courtNames: board && board.courtNames ? board.courtNames : undefined,
      };
      const rev = Date.now();
      try {
        await upsertDataset(tid, 'matches', { matches, settings, _rev: rev });
        try { localStorage.setItem('lastPushRev_' + tid, String(rev)); } catch {}
        const lbl = document.getElementById('last-sync-label');
        if (lbl) lbl.textContent = 'æœ€çµ‚æ›´æ–°: ' + new Date().toLocaleString('ja-JP');
        showToast('ã‚¯ãƒ©ã‚¦ãƒ‰ã«ä¿å­˜ã—ã¾ã—ãŸ');
      } catch (e) {
        console.warn('[OP] pushNow failed', e);
        // Show non-blocking toast with reason
        const reason = (e && (e.message || e.error_description || e.code)) ? String(e.message || e.error_description || e.code) : 'æ¨©é™/ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯';
        try { showToast('ã‚¯ãƒ©ã‚¦ãƒ‰ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆ' + reason + 'ï¼‰'); } catch {}
        // Additionally show alert with brief guidance once per session
        try {
          if (!sessionStorage.getItem('op_push_error_alerted')) {
            sessionStorage.setItem('op_push_error_alerted', '1');
            alert('ã‚¯ãƒ©ã‚¦ãƒ‰ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\nç†ç”±: ' + reason + '\n\nå¯¾å‡¦ä¾‹:\n- ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ã‹ç¢ºèªï¼ˆå³ä¸Šã€Œç®¡ç†ã€ï¼‰\n- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯/HTTPS ã‚’ç¢ºèª\n- Supabase ã® datasets ãƒ†ãƒ¼ãƒ–ãƒ«ã¨ RLS ãƒãƒªã‚·ãƒ¼ã‚’ç¢ºèª\nï¼ˆanon ãƒ­ãƒ¼ãƒ«ã«å¯¾ã—ã¦ insert/update è¨±å¯ï¼‰');
          }
        } catch {}
        // Keep local state; do not throw further
      }
    }

    // expose for external callers (e.g., board.js, app.js, matchCard.js)
    window.pushNow = pushNow;
    window.pullLatest = pullLatest;
    window.isAdmin = isAdmin;

    // Debounced auto push helper (admin only)
    let autoPushTimer = null;
    window.maybeAutoPush = function(reason = 'auto') {
      try {
        if (!isAdmin()) return; // viewer mode: do nothing silently
        if (autoPushTimer) clearTimeout(autoPushTimer);
        autoPushTimer = setTimeout(() => {
          pushNow().catch(e => console.warn('auto push failed', e));
        }, 1200);
      } catch (e) { console.warn('maybeAutoPush error', e); }
    };

    // ç®¡ç†è€…åˆ‡æ›¿
    function toggleAdmin() {
      if (isAdmin()) {
        localStorage.setItem(ADMIN_FLAG_KEY, '0');
        alert('é–²è¦§è€…ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡æ›¿ãˆã¾ã—ãŸ');
      } else {
        const pass = prompt('ç®¡ç†è€…ãƒ‘ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›');
        const saved = localStorage.getItem(PASSCODE_KEY) || '';
        if (!saved) {
          // åˆå›è¨­å®š
          if (pass && pass.length >= 4) {
            localStorage.setItem(PASSCODE_KEY, pass);
            localStorage.setItem(ADMIN_FLAG_KEY, '1');
            alert('ç®¡ç†è€…ãƒ‘ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è¨­å®šã—ç®¡ç†è€…ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡æ›¿ãˆã¾ã—ãŸ');
          } else {
            alert('4æ–‡å­—ä»¥ä¸Šã‚’è¨­å®šã—ã¦ãã ã•ã„');
          }
        } else if (pass === saved) {
          localStorage.setItem(ADMIN_FLAG_KEY, '1');
          alert('ç®¡ç†è€…ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡æ›¿ãˆã¾ã—ãŸ');
        } else {
          alert('ãƒ‘ã‚¹ã‚³ãƒ¼ãƒ‰ãŒé•ã„ã¾ã™');
        }
      }
      updateAdminUI();
    }

    function updateAdminUI() {
      const admin = isAdmin();
      // Viewer mode: when not admin, add class to hide edit/admin UI via CSS
      document.body.classList.toggle('viewer-mode', !admin);

      // Keep button disabled states for safety
      document.getElementById('cloud-push-btn').disabled = !admin;
      document.getElementById('delete-all-matches-btn').disabled = !admin;
      document.getElementById('add-match-btn').disabled = !admin;
    }

    // é–¢æ•°ã‚’ãƒ‡ãƒãƒƒã‚°ã—ã‚„ã™ã„ã‚ˆã†ã«å…¬é–‹
    window.pullLatest = pullLatest;
    window.pullMeta = pullMeta;
    window.pushNow = pushNow;

    // åˆæœŸåŒ–é–¢æ•°ï¼ˆDOMContentLoaded å¾Œã«è¿½åŠ ã•ã‚ŒãŸå ´åˆã§ã‚‚å³æ™‚ãƒã‚¤ãƒ³ãƒ‰ã§ãã‚‹ã‚ˆã†ã«ï¼‰
    async function initCloudControls() {
      const pullBtn = document.getElementById('cloud-pull-btn');
      const pushBtn = document.getElementById('cloud-push-btn');
      const toggleBtn = document.getElementById('toggle-admin-btn');
      const adminEntry = document.getElementById('viewer-admin-entry');
      if (pullBtn) pullBtn.addEventListener('click', async () => { await pullLatest(); await pullMeta(); });
      if (pushBtn) pushBtn.addEventListener('click', pushNow);
      if (toggleBtn) toggleBtn.addEventListener('click', toggleAdmin);
      if (adminEntry) adminEntry.addEventListener('click', toggleAdmin);
      console.log('[OP] cloud controls bound');

      // åˆæœŸè¡¨ç¤º
      await ensureTables();
      updateAdminUI();
      await pullMeta();

      // ã‚³ãƒ”ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ã«ç¾åœ¨ã®tidã‚’åæ˜ ã—ã‚¯ãƒªãƒƒã‚¯ã§ã‚³ãƒ”ãƒ¼
      try {
        const copyBtn = document.getElementById('copy-tid-btn');
        const updateBtn = () => {
          const tid = getTournamentId();
          if (copyBtn) copyBtn.title = 'å¤§ä¼šIDã‚’ã‚³ãƒ”ãƒ¼: ' + tid;
        };
        updateBtn();
        if (copyBtn) {
          copyBtn.addEventListener('click', async () => {
            try {
              const tid = getTournamentId();
              await navigator.clipboard.writeText(tid);
              if (typeof showToast === 'function') showToast('å¤§ä¼šIDã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
            } catch (e) {
              alert('ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
          });
        }
      } catch {}

      // Auto fetch latest
      try {
        const sp = new URLSearchParams(location.search);
        const hasTid = !!sp.get('tid');
        const alreadyPulled = sessionStorage.getItem('op_auto_pulled_once') === '1';
        // Viewer mode: always auto-pull on every load (ignore session flag)
        if (!isAdmin()) {
          await pullLatest();
        } else if (hasTid && !alreadyPulled) {
          // Admin mode: keep previous behavior to avoid loops
          await pullLatest();
        }
      } catch (e) { console.warn('auto pull on load failed', e); }

      // åˆæœŸåŒ–æ™‚ã«æœ€çµ‚æ›´æ–°æ™‚åˆ»ã‚’ localStorage ã‹ã‚‰åæ˜ 
      try {
        const ts = localStorage.getItem('lastSyncTime');
        const label = document.getElementById('last-sync-label');
        if (ts && label) {
          label.textContent = 'æœ€çµ‚æ›´æ–°: ' + new Date(ts).toLocaleString('ja-JP');
        }
      } catch {}

      // Fallback: if local matches are empty, try pulling once more (only once per session)
      try {
        const tid = getTournamentId();
        const key = (typeof window.getMatchDataKey === 'function') ? window.getMatchDataKey(tid) : ('tennisTournamentMatches_' + tid);
        const raw = localStorage.getItem(key);
        const arr = raw ? JSON.parse(raw) : [];
        const alreadyPulled = sessionStorage.getItem('op_fallback_tried') === '1';
        if (!alreadyPulled && (!arr || (Array.isArray(arr) && arr.length === 0))) {
          sessionStorage.setItem('op_fallback_tried', '1');
          await pullLatest();
        }
      } catch (e) { console.warn('fallback pull failed', e); }

      // Mobile/app-switch: when page becomes visible again, auto-pull in viewer mode
      try {
        document.addEventListener('visibilitychange', async () => {
          if (!document.hidden && !isAdmin()) {
            await pullLatest();
          }
        });
      } catch (e) { console.warn('visibilitychange bind failed', e); }
    }

    // DOM æº–å‚™çŠ¶æ…‹ã«å¿œã˜ã¦åˆæœŸåŒ–ã‚’å®Ÿè¡Œ
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initCloudControls, { once: true });
    } else {
      // æ—¢ã«èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰å³æ™‚å®Ÿè¡Œ
      initCloudControls();
    }
  </script>
</body>
</html>
